{"version":3,"sources":["index.js"],"names":["shuffle","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","a","canvas","document","getElementById","viewport","createViewport","cellTypes","i","push","cells","x","y","type","solved","flipped","transition","transitionDuration","transitionExpire","transitionDelay","getCell","drawWidth","offsetY","size","pad","offsetX","shadowOffsetX","shadowOffsetY","gl","getContext","camera","getCamera","inputHandler","createViewportAwareInputHandler","batch","createBatch","loadTexture","bgTexture","loadAtlas","atlas","cardRegions","findRegions","backRegion","findRegion","shadowRegion","clicked","startTime","Date","now","move","addEventListener","getTouchedWorldCoord","cellX","cellY","cell","cell1","cell2","setTimeout","clearColor","update","delta","clear","COLOR_BUFFER_BIT","setProjection","combined","begin","draw","hidden","alert","region","drawX","drawY","scaleX","abs","scale","end","createGameLoop","init"],"mappings":"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","file":"static/js/main.eb99f46f.chunk.js","sourcesContent":["import './index.css';\nimport {\n  createViewport,\n  createViewportAwareInputHandler,\n  createBatch,\n  createGameLoop,\n  loadTexture,\n  loadAtlas\n} from 'gdxjs';\n\nfunction shuffle(array) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  while (0 !== currentIndex) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n}\n\nconst init = async () => {\n  const worldWidth = 47;\n  const worldHeight = 100;\n\n  const canvas = document.getElementById('main');\n  const viewport = createViewport(canvas, 47, 100);\n\n  const cellTypes = [];\n  for (let i = 0; i < 12; i++) {\n    cellTypes.push(i % 6);\n  }\n  shuffle(cellTypes);\n  const cells = [];\n  for (let i = 0; i < cellTypes.length; i++) {\n    cells.push({\n      x: i % 3,\n      y: Math.floor(i / 3),\n      type: cellTypes[i],\n      solved: false,\n      flipped: false,\n      transition: false,\n      transitionDuration: 0,\n      transitionExpire: 0,\n      transitionDelay: 0\n    });\n  }\n\n  const getCell = (x, y) => {\n    return cells[y * 3 + x];\n  };\n\n  let margin,\n    pad,\n    size,\n    offsetY,\n    offsetX,\n    drawWidth,\n    shadowOffsetX,\n    shadowOffsetY;\n\n  drawWidth = worldWidth;\n  margin = drawWidth * 0.05;\n  pad = drawWidth * 0.03;\n  size = (drawWidth - 2 * margin - 2 * pad) / 3;\n  offsetY = (worldHeight - size * 4 - pad * 3) / 2;\n  offsetX = margin;\n\n  shadowOffsetX = 0;\n  shadowOffsetY = size * 0.06;\n\n  const gl = viewport.getContext();\n  const camera = viewport.getCamera();\n\n  const inputHandler = createViewportAwareInputHandler(canvas, viewport);\n  const batch = createBatch(gl);\n  const bgTexture = await loadTexture(gl, './bg.png');\n  const atlas = await loadAtlas(gl, './atlas/tingme-flipcard.atlas');\n\n  const cardRegions = atlas.findRegions('card');\n  const backRegion = atlas.findRegion('back');\n  const shadowRegion = atlas.findRegion('shadow');\n\n  const TRANSITIONING_UP = 'up';\n  const TRANSITIONING_DOWN = 'down';\n  const TRANSITION_AWAY = 'away';\n\n  const clicked = [];\n  let flipped = 0;\n\n  let startTime = Date.now();\n  let move = 0;\n\n  inputHandler.addEventListener('touchStart', () => {\n    if (flipped >= 2) {\n      return;\n    }\n    const x = inputHandler.getTouchedWorldCoord().x;\n    const y = inputHandler.getTouchedWorldCoord().y;\n    const cellX = Math.floor((x - offsetX) / (pad + size));\n    const cellY = Math.floor((y - offsetY) / (pad + size));\n    if (cellX < 0 || cellY < 0 || cellX > 2 || cellY > 3) return;\n    const cell = getCell(cellX, cellY);\n    if (cell.solved || cell.transition || cell.flipped) return;\n    cell.transition = TRANSITIONING_UP;\n    cell.transitionDuration = 0.2;\n    cell.transitionExpire = 0.2;\n    move++;\n    flipped++;\n    clicked.push(cell);\n\n    if (flipped >= 2) {\n      if (clicked[0].type === clicked[1].type) {\n        for (let cell of clicked) {\n          cell.solved = true;\n        }\n        const cell1 = clicked[0];\n        const cell2 = clicked[1];\n        flipped = 0;\n        clicked.length = 0;\n        setTimeout(() => {\n          cell1.transition = TRANSITION_AWAY;\n          cell1.transitionDuration = 0.2;\n          cell1.transitionExpire = 0.2;\n\n          cell2.transition = TRANSITION_AWAY;\n          cell2.transitionDuration = 0.2;\n          cell2.transitionExpire = 0.2;\n        }, 500);\n      } else {\n        setTimeout(() => {\n          for (let cell of clicked) {\n            cell.transition = TRANSITIONING_DOWN;\n            cell.transitionDuration = 0.2;\n            cell.transitionExpire = 0.2;\n          }\n          clicked.length = 0;\n          flipped = 0;\n        }, 500);\n      }\n    }\n  });\n\n  gl.clearColor(0, 0, 0, 0);\n  let solved = 0;\n  const update = delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    batch.setProjection(camera.combined);\n    batch.begin();\n    batch.draw(bgTexture, 0, 0, 47, 100);\n\n    for (let cell of cells) {\n      if (cell.transition) {\n        cell.transitionExpire -= delta;\n        if (cell.transitionExpire <= 0) {\n          if (cell.transition === TRANSITIONING_UP) {\n            cell.flipped = true;\n          } else if (cell.transition === TRANSITIONING_DOWN) {\n            cell.flipped = false;\n          } else {\n            cell.hidden = true;\n            solved++;\n            if (solved === cells.length) {\n              alert(\n                `You have completed the game in ${move} moves, ${Math.floor(\n                  (Date.now() - startTime) / 1000\n                )} seconds.`\n              );\n            }\n          }\n          cell.transition = false;\n          cell.transitionDuration = 0;\n          cell.transitionExpire = 0;\n        }\n      }\n    }\n\n    for (let cell of cells) {\n      if (cell.hidden) {\n        continue;\n      }\n      const region = cardRegions[cell.type];\n      const drawX = offsetX + cell.x * (size + pad);\n      const drawY = offsetY + cell.y * (size + pad);\n\n      if (!cell.transition) {\n        shadowRegion.draw(\n          batch,\n          drawX + shadowOffsetX,\n          drawY + shadowOffsetY,\n          size,\n          size\n        );\n        if (cell.flipped) {\n          region.draw(batch, drawX, drawY, size, size);\n        } else {\n          backRegion.draw(batch, drawX, drawY, size, size);\n        }\n      } else if (\n        cell.transition === TRANSITIONING_UP ||\n        cell.transition === TRANSITIONING_DOWN\n      ) {\n        const scaleX =\n          (Math.abs(cell.transitionExpire - cell.transitionDuration / 2) /\n            cell.transitionDuration) *\n          2;\n        shadowRegion.draw(\n          batch,\n          drawX + shadowOffsetX,\n          drawY + shadowOffsetY,\n          size,\n          size,\n          size / 2,\n          size / 2,\n          0,\n          scaleX,\n          1\n        );\n        if (\n          (cell.transitionExpire > cell.transitionDuration / 2) ^\n          (cell.transition === TRANSITIONING_DOWN)\n        ) {\n          backRegion.draw(\n            batch,\n            drawX,\n            drawY,\n            size,\n            size,\n            size / 2,\n            size / 2,\n            0,\n            scaleX,\n            1\n          );\n        } else {\n          region.draw(\n            batch,\n            drawX,\n            drawY,\n            size,\n            size,\n            size / 2,\n            size / 2,\n            0,\n            scaleX,\n            1\n          );\n        }\n      } else {\n        const scale = cell.transitionExpire / cell.transitionDuration;\n        shadowRegion.draw(\n          batch,\n          drawX + shadowOffsetX,\n          drawY + shadowOffsetY,\n          size,\n          size,\n          size / 2,\n          size / 2,\n          0,\n          scale,\n          scale\n        );\n        region.draw(\n          batch,\n          drawX,\n          drawY,\n          size,\n          size,\n          size / 2,\n          size / 2,\n          0,\n          scale,\n          scale\n        );\n      }\n    }\n\n    batch.end();\n  };\n  createGameLoop(update);\n};\n\ninit();\n"],"sourceRoot":""}